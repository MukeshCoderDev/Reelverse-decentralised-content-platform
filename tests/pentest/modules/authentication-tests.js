/**
 * Authentication Penetration Tests
 * Tests authentication mechanisms for vulnerabilities
 */

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Counter } from 'k6/metrics';

// Metrics
const authVulnerabilities = new Counter('auth_vulnerabilities');
const authTestsRun = new Counter('auth_tests_run');
const criticalFindings = new Counter('critical_findings');

export class AuthenticationTests {
  constructor(config) {
    this.config = config;
    this.baseUrl = config.target.baseUrl;
    this.apiPrefix = config.target.apiPrefix;
    this.findings = [];
  }

  async runAllTests() {
    console.log('üîê Running Authentication Penetration Tests');
    
    const tests = [
      this.testJWTTokenManipulation,
      this.testSessionHijacking,
      this.testBruteForceProtection,
      this.testSIWESignatureBypass,
      this.testAccountLockout,
      this.testPasswordPolicy,
      this.testAuthenticationBypass
    ];

    for (const test of tests) {
      try {
        await test.call(this);
        authTestsRun.add(1);
      } catch (error) {
        console.error(`Authentication test failed: ${error.message}`);
      }
      sleep(1); // Rate limiting
    }

    return this.findings;
  }

  async testJWTTokenManipulation() {
    console.log('Testing JWT Token Manipulation...');
    
    // 1. Get valid JWT token
    const loginResponse = await this.performLogin();
    if (!loginResponse || loginResponse.status !== 200) {
      return;
    }

    const token = this.extractToken(loginResponse);
    if (!token) return;

    // 2. Test token manipulation attacks
    const manipulationTests = [
      {
        name: 'None Algorithm Attack',
        token: this.manipulateJWTAlgorithm(token, 'none'),
        severity: 'critical'
      },
      {
        name: 'Algorithm Confusion (HS256 to RS256)',
        token: this.manipulateJWTAlgorithm(token, 'RS256'),
        severity: 'high'
      },
      {
        name: 'Payload Manipulation',
        token: this.manipulateJWTPayload(token, { role: 'admin' }),
        severity: 'critical'
      },
      {
        name: 'Signature Removal',
        token: this.removeJWTSignature(token),
        severity: 'critical'
      },
      {
        name: 'Expired Token Usage',
        token: this.createExpiredToken(token),
        severity: 'medium'
      }
    ];

    for (const test of manipulationTests) {
      const response = http.get(`${this.baseUrl}${this.apiPrefix}/users/profile`, {
        headers: { 'Authorization': `Bearer ${test.token}` }
      });

      if (response.status === 200) {
        this.addFinding({
          category: 'Authentication',
          test: 'JWT Token Manipulation',
          vulnerability: test.name,
          severity: test.severity,
          description: `JWT token manipulation successful: ${test.name}`,
          evidence: {
            request: `GET ${this.apiPrefix}/users/profile`,
            token: test.token,
            response: response.status
          },
          impact: 'Unauthorized access to protected resources',
          recommendation: 'Implement proper JWT validation and signature verification'
        });

        authVulnerabilities.add(1);
        if (test.severity === 'critical') {
          criticalFindings.add(1);
        }
      }
    }
  }

  async testSessionHijacking() {
    console.log('Testing Session Hijacking...');
    
    // 1. Create valid session
    const loginResponse = await this.performLogin();
    if (!loginResponse || loginResponse.status !== 200) return;

    const sessionCookie = this.extractSessionCookie(loginResponse);
    if (!sessionCookie) return;

    // 2. Test session fixation
    const fixedSessionId = 'fixed_session_12345';
    const fixationResponse = http.post(`${this.baseUrl}${this.apiPrefix}/auth/login`, 
      JSON.stringify({
        email: this.config.authentication.testUsers[0].email,
        sessionId: fixedSessionId
      }),
      {
        headers: { 'Content-Type': 'application/json' },
        cookies: { sessionId: fixedSessionId }
      }
    );

    if (fixationResponse.status === 200) {
      this.addFinding({
        category: 'Authentication',
        test: 'Session Hijacking',
        vulnerability: 'Session Fixation',
        severity: 'high',
        description: 'Application accepts pre-set session IDs',
        evidence: {
          fixedSessionId: fixedSessionId,
          response: fixationResponse.status
        },
        impact: 'Attacker can hijack user sessions',
        recommendation: 'Generate new session IDs after successful authentication'
      });

      authVulnerabilities.add(1);
    }

    // 3. Test concurrent session handling
    const concurrentResponse = http.get(`${this.baseUrl}${this.apiPrefix}/users/profile`, {
      headers: { 'Cookie': sessionCookie }
    });

    // Login from different location
    const secondLoginResponse = await this.performLogin();
    
    // Check if first session is still valid
    const firstSessionCheck = http.get(`${this.baseUrl}${this.apiPrefix}/users/profile`, {
      headers: { 'Cookie': sessionCookie }
    });

    if (firstSessionCheck.status === 200 && secondLoginResponse.status === 200) {
      this.addFinding({
        category: 'Authentication',
        test: 'Session Hijacking',
        vulnerability: 'Concurrent Session Allowed',
        severity: 'medium',
        description: 'Multiple concurrent sessions allowed for same user',
        impact: 'Increased attack surface for session hijacking',
        recommendation: 'Implement session management to limit concurrent sessions'
      });

      authVulnerabilities.add(1);
    }
  }

  async testBruteForceProtection() {
    console.log('Testing Brute Force Protection...');
    
    const testUser = this.config.authentication.testUsers[1];
    const wrongPasswords = [
      'wrongpass1', 'wrongpass2', 'wrongpass3', 'wrongpass4', 'wrongpass5',
      'password123', 'admin', '123456', 'qwerty', 'letmein'
    ];

    let successfulAttempts = 0;
    let lockedOut = false;

    for (let i = 0; i < wrongPasswords.length; i++) {
      const response = http.post(`${this.baseUrl}${this.apiPrefix}/auth/login`,
        JSON.stringify({
          email: testUser.email,
          password: wrongPasswords[i]
        }),
        {
          headers: { 'Content-Type': 'application/json' }
        }
      );

      if (response.status === 429 || response.body.includes('locked') || response.body.includes('blocked')) {
        lockedOut = true;
        break;
      }

      if (response.status !== 401 && response.status !== 403) {
        successfulAttempts++;
      }

      sleep(0.5); // Small delay between attempts
    }

    if (!lockedOut) {
      this.addFinding({
        category: 'Authentication',
        test: 'Brute Force Protection',
        vulnerability: 'No Brute Force Protection',
        severity: 'high',
        description: `No account lockout after ${wrongPasswords.length} failed attempts`,
        evidence: {
          attempts: wrongPasswords.length,
          successfulAttempts: successfulAttempts
        },
        impact: 'Attackers can perform unlimited password guessing attacks',
        recommendation: 'Implement account lockout and rate limiting for login attempts'
      });

      authVulnerabilities.add(1);
    }

    // Test rate limiting bypass techniques
    await this.testRateLimitBypass(testUser.email);
  }

  async testSIWESignatureBypass() {
    console.log('Testing SIWE Signature Bypass...');
    
    const testUser = this.config.authentication.testUsers[0];
    
    // 1. Get nonce
    const nonceResponse = http.post(`${this.baseUrl}${this.apiPrefix}/auth/siwe/nonce`,
      JSON.stringify({ address: testUser.walletAddress }),
      { headers: { 'Content-Type': 'application/json' } }
    );

    if (nonceResponse.status !== 200) return;

    const nonce = JSON.parse(nonceResponse.body).nonce;

    // 2. Test signature bypass attempts
    const bypassTests = [
      {
        name: 'Empty Signature',
        signature: '',
        severity: 'critical'
      },
      {
        name: 'Invalid Signature Format',
        signature: 'invalid_signature_format',
        severity: 'critical'
      },
      {
        name: 'Reused Signature',
        signature: '0x' + 'a'.repeat(130), // Mock signature
        severity: 'high'
      },
      {
        name: 'Modified Message',
        message: 'modified_message_content',
        signature: '0x' + 'b'.repeat(130),
        severity: 'critical'
      }
    ];

    for (const test of bypassTests) {
      const verifyResponse = http.post(`${this.baseUrl}${this.apiPrefix}/auth/siwe/verify`,
        JSON.stringify({
          message: test.message || `Sign in to platform with nonce: ${nonce}`,
          signature: test.signature
        }),
        { headers: { 'Content-Type': 'application/json' } }
      );

      if (verifyResponse.status === 200) {
        this.addFinding({
          category: 'Authentication',
          test: 'SIWE Signature Bypass',
          vulnerability: test.name,
          severity: test.severity,
          description: `SIWE signature verification bypassed: ${test.name}`,
          evidence: {
            signature: test.signature,
            response: verifyResponse.status
          },
          impact: 'Unauthorized authentication without valid wallet signature',
          recommendation: 'Implement proper SIWE signature validation and verification'
        });

        authVulnerabilities.add(1);
        if (test.severity === 'critical') {
          criticalFindings.add(1);
        }
      }
    }
  }

  async testAccountLockout() {
    console.log('Testing Account Lockout Mechanisms...');
    
    // Test if account lockout can be bypassed
    const testUser = this.config.authentication.testUsers[2];
    
    // Attempt to trigger lockout
    for (let i = 0; i < 10; i++) {
      http.post(`${this.baseUrl}${this.apiPrefix}/auth/login`,
        JSON.stringify({
          email: testUser.email,
          password: 'wrongpassword'
        }),
        { headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Test lockout bypass techniques
    const bypassTests = [
      {
        name: 'Case Variation',
        email: testUser.email.toUpperCase()
      },
      {
        name: 'Space Addition',
        email: ` ${testUser.email} `
      },
      {
        name: 'Different User Agent',
        headers: { 'User-Agent': 'Different-Agent/1.0' }
      },
      {
        name: 'X-Forwarded-For Header',
        headers: { 'X-Forwarded-For': '192.168.1.100' }
      }
    ];

    for (const test of bypassTests) {
      const response = http.post(`${this.baseUrl}${this.apiPrefix}/auth/login`,
        JSON.stringify({
          email: test.email || testUser.email,
          password: 'wrongpassword'
        }),
        {
          headers: {
            'Content-Type': 'application/json',
            ...test.headers
          }
        }
      );

      if (response.status !== 429 && !response.body.includes('locked')) {
        this.addFinding({
          category: 'Authentication',
          test: 'Account Lockout',
          vulnerability: `Lockout Bypass - ${test.name}`,
          severity: 'medium',
          description: `Account lockout bypassed using ${test.name}`,
          evidence: {
            bypassMethod: test.name,
            response: response.status
          },
          impact: 'Attackers can bypass account lockout mechanisms',
          recommendation: 'Implement robust lockout mechanisms that cannot be easily bypassed'
        });

        authVulnerabilities.add(1);
      }
    }
  }

  async testPasswordPolicy() {
    console.log('Testing Password Policy...');
    
    const weakPasswords = [
      'password',
      '123456',
      'admin',
      'test',
      'qwerty',
      'a', // Too short
      '12345', // Only numbers
      'abcdef' // Only letters
    ];

    for (const password of weakPasswords) {
      const response = http.post(`${this.baseUrl}${this.apiPrefix}/auth/register`,
        JSON.stringify({
          email: `test_${Date.now()}@test.com`,
          password: password,
          walletAddress: '0x' + Math.random().toString(16).substr(2, 40)
        }),
        { headers: { 'Content-Type': 'application/json' } }
      );

      if (response.status === 200 || response.status === 201) {
        this.addFinding({
          category: 'Authentication',
          test: 'Password Policy',
          vulnerability: 'Weak Password Accepted',
          severity: 'medium',
          description: `Weak password accepted: "${password}"`,
          evidence: {
            password: password,
            response: response.status
          },
          impact: 'Users can set weak passwords vulnerable to attacks',
          recommendation: 'Implement strong password policy with complexity requirements'
        });

        authVulnerabilities.add(1);
      }
    }
  }

  async testAuthenticationBypass() {
    console.log('Testing Authentication Bypass...');
    
    // Test direct access to protected endpoints
    const protectedEndpoints = [
      '/users/profile',
      '/admin/users',
      '/payments/history',
      '/content/create',
      '/studio/analytics'
    ];

    for (const endpoint of protectedEndpoints) {
      const response = http.get(`${this.baseUrl}${this.apiPrefix}${endpoint}`);
      
      if (response.status === 200) {
        this.addFinding({
          category: 'Authentication',
          test: 'Authentication Bypass',
          vulnerability: 'Unauthenticated Access',
          severity: 'critical',
          description: `Protected endpoint accessible without authentication: ${endpoint}`,
          evidence: {
            endpoint: endpoint,
            response: response.status,
            responseBody: response.body.substring(0, 200)
          },
          impact: 'Unauthorized access to protected resources',
          recommendation: 'Implement proper authentication checks on all protected endpoints'
        });

        authVulnerabilities.add(1);
        criticalFindings.add(1);
      }
    }
  }

  async testRateLimitBypass(email) {
    const bypassTechniques = [
      {
        name: 'X-Forwarded-For',
        headers: { 'X-Forwarded-For': '192.168.1.' + Math.floor(Math.random() * 255) }
      },
      {
        name: 'X-Real-IP',
        headers: { 'X-Real-IP': '10.0.0.' + Math.floor(Math.random() * 255) }
      },
      {
        name: 'User-Agent Rotation',
        headers: { 'User-Agent': `TestAgent-${Math.random()}` }
      }
    ];

    for (const technique of bypassTechniques) {
      const response = http.post(`${this.baseUrl}${this.apiPrefix}/auth/login`,
        JSON.stringify({
          email: email,
          password: 'wrongpassword'
        }),
        {
          headers: {
            'Content-Type': 'application/json',
            ...technique.headers
          }
        }
      );

      if (response.status !== 429) {
        this.addFinding({
          category: 'Authentication',
          test: 'Rate Limit Bypass',
          vulnerability: `Rate Limit Bypass - ${technique.name}`,
          severity: 'medium',
          description: `Rate limiting bypassed using ${technique.name}`,
          impact: 'Attackers can bypass rate limiting protections',
          recommendation: 'Implement rate limiting that cannot be bypassed with header manipulation'
        });

        authVulnerabilities.add(1);
      }
    }
  }

  // Helper methods
  async performLogin() {
    const testUser = this.config.authentication.testUsers[0];
    return http.post(`${this.baseUrl}${this.apiPrefix}/auth/login`,
      JSON.stringify({
        email: testUser.email,
        password: 'testpassword123'
      }),
      { headers: { 'Content-Type': 'application/json' } }
    );
  }

  extractToken(response) {
    try {
      const body = JSON.parse(response.body);
      return body.token || body.accessToken || body.jwt;
    } catch {
      return null;
    }
  }

  extractSessionCookie(response) {
    const cookies = response.headers['Set-Cookie'];
    if (cookies) {
      const sessionCookie = cookies.find(cookie => cookie.includes('sessionId') || cookie.includes('session'));
      return sessionCookie ? sessionCookie.split(';')[0] : null;
    }
    return null;
  }

  manipulateJWTAlgorithm(token, newAlgorithm) {
    try {
      const parts = token.split('.');
      const header = JSON.parse(atob(parts[0]));
      header.alg = newAlgorithm;
      const newHeader = btoa(JSON.stringify(header));
      return `${newHeader}.${parts[1]}.${parts[2]}`;
    } catch {
      return token;
    }
  }

  manipulateJWTPayload(token, newClaims) {
    try {
      const parts = token.split('.');
      const payload = JSON.parse(atob(parts[1]));
      Object.assign(payload, newClaims);
      const newPayload = btoa(JSON.stringify(payload));
      return `${parts[0]}.${newPayload}.${parts[2]}`;
    } catch {
      return token;
    }
  }

  removeJWTSignature(token) {
    const parts = token.split('.');
    return `${parts[0]}.${parts[1]}.`;
  }

  createExpiredToken(token) {
    try {
      const parts = token.split('.');
      const payload = JSON.parse(atob(parts[1]));
      payload.exp = Math.floor(Date.now() / 1000) - 3600; // Expired 1 hour ago
      const newPayload = btoa(JSON.stringify(payload));
      return `${parts[0]}.${newPayload}.${parts[2]}`;
    } catch {
      return token;
    }
  }

  addFinding(finding) {
    this.findings.push({
      ...finding,
      timestamp: new Date().toISOString(),
      testId: `auth_${this.findings.length + 1}`
    });
  }
}