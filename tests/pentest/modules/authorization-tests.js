/**
 * Authorization Penetration Tests
 * Tests authorization and access control mechanisms
 */

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Counter } from 'k6/metrics';

// Metrics
const authzVulnerabilities = new Counter('authz_vulnerabilities');
const authzTestsRun = new Counter('authz_tests_run');
const privilegeEscalations = new Counter('privilege_escalations');

export class AuthorizationTests {
  constructor(config) {
    this.config = config;
    this.baseUrl = config.target.baseUrl;
    this.apiPrefix = config.target.apiPrefix;
    this.findings = [];
    this.userTokens = {};
  }

  async runAllTests() {
    console.log('ðŸ”’ Running Authorization Penetration Tests');
    
    // Setup user sessions
    await this.setupUserSessions();
    
    const tests = [
      this.testPrivilegeEscalation,
      this.testHorizontalAccessControl,
      this.testVerticalAccessControl,
      this.testRoleBasedAccess,
      this.testResourceAccessControl,
      this.testAPIEndpointAuthorization,
      this.testDirectObjectReference,
      this.testParameterTampering
    ];

    for (const test of tests) {
      try {
        await test.call(this);
        authzTestsRun.add(1);
      } catch (error) {
        console.error(`Authorization test failed: ${error.message}`);
      }
      sleep(1);
    }

    return this.findings;
  }

  async setupUserSessions() {
    console.log('Setting up user sessions for authorization tests...');
    
    for (const user of this.config.authentication.testUsers) {
      try {
        const loginResponse = http.post(`${this.baseUrl}${this.apiPrefix}/auth/login`,
          JSON.stringify({
            email: user.email,
            password: 'testpassword123'
          }),
          { headers: { 'Content-Type': 'application/json' } }
        );

        if (loginResponse.status === 200) {
          const token = this.extractToken(loginResponse);
          if (token) {
            this.userTokens[user.role] = token;
          }
        }
      } catch (error) {
        console.warn(`Failed to setup session for ${user.role}: ${error.message}`);
      }
    }
  }

  async testPrivilegeEscalation() {
    console.log('Testing Privilege Escalation...');
    
    if (!this.userTokens.consumer || !this.userTokens.admin) {
      console.warn('Missing required user tokens for privilege escalation test');
      return;
    }

    // Test 1: Consumer trying to access admin endpoints
    const adminEndpoints = [
      '/admin/users',
      '/admin/content/moderate',
      '/admin/payments/refund',
      '/admin/analytics/revenue',
      '/admin/system/config'
    ];

    for (const endpoint of adminEndpoints) {
      const response = http.get(`${this.baseUrl}${this.apiPrefix}${endpoint}`, {
        headers: { 'Authorization': `Bearer ${this.userTokens.consumer}` }
      });

      if (response.status === 200) {
        this.addFinding({
          category: 'Authorization',
          test: 'Privilege Escalation',
          vulnerability: 'Consumer Access to Admin Endpoint',
          severity: 'critical',
          description: `Consumer user can access admin endpoint: ${endpoint}`,
          evidence: {
            endpoint: endpoint,
            userRole: 'consumer',
            response: response.status,
            responseBody: response.body.substring(0, 200)
          },
          impact: 'Unauthorized access to administrative functions',
          recommendation: 'Implement proper role-based access control checks'
        });

        authzVulnerabilities.add(1);
        privilegeEscalations.add(1);
      }
    }

    // Test 2: Role manipulation in requests
    await this.testRoleManipulation();

    // Test 3: JWT payload manipulation for privilege escalation
    await this.testJWTPrivilegeEscalation();
  }

  async testHorizontalAccessControl() {
    console.log('Testing Horizontal Access Control...');
    
    if (!this.userTokens.creator || !this.userTokens.consumer) {
      console.warn('Missing required user tokens for horizontal access control test');
      return;
    }

    // Test accessing other users' resources
    const testCases = [
      {
        name: 'User Profile Access',
        endpoint: '/users/profile/other-user-id',
        description: 'Access to other user\'s profile'
      },
      {
        name: 'Payment History Access',
        endpoint: '/payments/history/other-user-address',
        description: 'Access to other user\'s payment history'
      },
      {
        name: 'Content Management Access',
        endpoint: '/content/manage/other-user-content',
        description: 'Access to other user\'s content management'
      },
      {
        name: 'Earnings Access',
        endpoint: '/earnings/other-user-address',
        description: 'Access to other user\'s earnings data'
      }
    ];

    for (const testCase of testCases) {
      const response = http.get(`${this.baseUrl}${this.apiPrefix}${testCase.endpoint}`, {
        headers: { 'Authorization': `Bearer ${this.userTokens.consumer}` }
      });

      if (response.status === 200) {
        this.addFinding({
          category: 'Authorization',
          test: 'Horizontal Access Control',
          vulnerability: testCase.name,
          severity: 'high',
          description: testCase.description,
          evidence: {
            endpoint: testCase.endpoint,
            response: response.status,
            responseBody: response.body.substring(0, 200)
          },
          impact: 'Users can access other users\' private data',
          recommendation: 'Implement proper user ownership validation'
        });

        authzVulnerabilities.add(1);
      }
    }

    // Test parameter manipulation for horizontal access
    await this.testParameterManipulation();
  }

  async testVerticalAccessControl() {
    console.log('Testing Vertical Access Control...');
    
    if (!this.userTokens.creator) {
      console.warn('Missing creator token for vertical access control test');
      return;
    }

    // Test creator trying to access admin functions
    const restrictedEndpoints = [
      {
        endpoint: '/admin/users/ban',
        method: 'POST',
        data: { userId: 'test-user-id', reason: 'test' }
      },
      {
        endpoint: '/admin/content/takedown',
        method: 'POST',
        data: { contentId: 'test-content-id', reason: 'dmca' }
      },
      {
        endpoint: '/admin/payments/refund',
        method: 'POST',
        data: { paymentId: 'test-payment-id', amount: 100 }
      },
      {
        endpoint: '/admin/system/maintenance',
        method: 'PUT',
        data: { enabled: true }
      }
    ];

    for (const test of restrictedEndpoints) {
      let response;
      
      if (test.method === 'POST') {
        response = http.post(`${this.baseUrl}${this.apiPrefix}${test.endpoint}`,
          JSON.stringify(test.data),
          {
            headers: {
              'Authorization': `Bearer ${this.userTokens.creator}`,
              'Content-Type': 'application/json'
            }
          }
        );
      } else if (test.method === 'PUT') {
        response = http.put(`${this.baseUrl}${this.apiPrefix}${test.endpoint}`,
          JSON.stringify(test.data),
          {
            headers: {
              'Authorization': `Bearer ${this.userTokens.creator}`,
              'Content-Type': 'application/json'
            }
          }
        );
      } else {
        response = http.get(`${this.baseUrl}${this.apiPrefix}${test.endpoint}`, {
          headers: { 'Authorization': `Bearer ${this.userTokens.creator}` }
        });
      }

      if (response.status === 200 || response.status === 201) {
        this.addFinding({
          category: 'Authorization',
          test: 'Vertical Access Control',
          vulnerability: 'Creator Access to Admin Function',
          severity: 'critical',
          description: `Creator can access admin function: ${test.endpoint}`,
          evidence: {
            endpoint: test.endpoint,
            method: test.method,
            userRole: 'creator',
            response: response.status
          },
          impact: 'Lower privilege users can perform administrative actions',
          recommendation: 'Implement strict role hierarchy enforcement'
        });

        authzVulnerabilities.add(1);
        privilegeEscalations.add(1);
      }
    }
  }

  async testRoleBasedAccess() {
    console.log('Testing Role-Based Access Control...');
    
    // Define role-based access matrix
    const accessMatrix = {
      consumer: {
        allowed: ['/content/browse', '/payments/create', '/users/profile'],
        denied: ['/content/create', '/admin/users', '/studio/analytics']
      },
      creator: {
        allowed: ['/content/create', '/studio/analytics', '/earnings/view'],
        denied: ['/admin/users', '/admin/payments/refund']
      },
      admin: {
        allowed: ['/admin/users', '/admin/content', '/admin/payments'],
        denied: [] // Admin should have access to everything
      }
    };

    for (const [role, access] of Object.entries(accessMatrix)) {
      if (!this.userTokens[role]) continue;

      // Test denied endpoints
      for (const endpoint of access.denied) {
        const response = http.get(`${this.baseUrl}${this.apiPrefix}${endpoint}`, {
          headers: { 'Authorization': `Bearer ${this.userTokens[role]}` }
        });

        if (response.status === 200) {
          this.addFinding({
            category: 'Authorization',
            test: 'Role-Based Access Control',
            vulnerability: 'Unauthorized Role Access',
            severity: 'high',
            description: `${role} role can access denied endpoint: ${endpoint}`,
            evidence: {
              role: role,
              endpoint: endpoint,
              response: response.status
            },
            impact: 'Role-based access controls are not properly enforced',
            recommendation: 'Review and enforce role-based access control matrix'
          });

          authzVulnerabilities.add(1);
        }
      }
    }
  }

  async testResourceAccessControl() {
    console.log('Testing Resource Access Control...');
    
    // Test content access control
    await this.testContentAccessControl();
    
    // Test payment resource access
    await this.testPaymentResourceAccess();
    
    // Test user data access
    await this.testUserDataAccess();
  }

  async testContentAccessControl() {
    if (!this.userTokens.consumer) return;

    // Test accessing premium content without payment
    const premiumContentTests = [
      '/content/premium-video-1/stream',
      '/content/premium-video-1/download',
      '/content/subscription-content/access'
    ];

    for (const endpoint of premiumContentTests) {
      const response = http.get(`${this.baseUrl}${this.apiPrefix}${endpoint}`, {
        headers: { 'Authorization': `Bearer ${this.userTokens.consumer}` }
      });

      if (response.status === 200) {
        this.addFinding({
          category: 'Authorization',
          test: 'Resource Access Control',
          vulnerability: 'Unauthorized Premium Content Access',
          severity: 'high',
          description: `User can access premium content without payment: ${endpoint}`,
          evidence: {
            endpoint: endpoint,
            response: response.status
          },
          impact: 'Users can access paid content without payment',
          recommendation: 'Implement proper payment verification for premium content'
        });

        authzVulnerabilities.add(1);
      }
    }
  }

  async testPaymentResourceAccess() {
    if (!this.userTokens.consumer) return;

    // Test accessing payment resources of other users
    const paymentTests = [
      '/payments/history/0x1234567890123456789012345678901234567890',
      '/payments/refund/other-user-payment-id',
      '/payments/analytics/other-user-address'
    ];

    for (const endpoint of paymentTests) {
      const response = http.get(`${this.baseUrl}${this.apiPrefix}${endpoint}`, {
        headers: { 'Authorization': `Bearer ${this.userTokens.consumer}` }
      });

      if (response.status === 200) {
        this.addFinding({
          category: 'Authorization',
          test: 'Resource Access Control',
          vulnerability: 'Unauthorized Payment Data Access',
          severity: 'high',
          description: `User can access other user's payment data: ${endpoint}`,
          evidence: {
            endpoint: endpoint,
            response: response.status
          },
          impact: 'Users can access other users\' financial information',
          recommendation: 'Implement proper ownership validation for payment resources'
        });

        authzVulnerabilities.add(1);
      }
    }
  }

  async testUserDataAccess() {
    if (!this.userTokens.consumer) return;

    // Test accessing other users' private data
    const userDataTests = [
      '/users/private-profile/other-user-id',
      '/users/settings/other-user-id',
      '/users/kyc-data/other-user-id'
    ];

    for (const endpoint of userDataTests) {
      const response = http.get(`${this.baseUrl}${this.apiPrefix}${endpoint}`, {
        headers: { 'Authorization': `Bearer ${this.userTokens.consumer}` }
      });

      if (response.status === 200) {
        this.addFinding({
          category: 'Authorization',
          test: 'Resource Access Control',
          vulnerability: 'Unauthorized User Data Access',
          severity: 'high',
          description: `User can access other user's private data: ${endpoint}`,
          evidence: {
            endpoint: endpoint,
            response: response.status
          },
          impact: 'Users can access other users\' private information',
          recommendation: 'Implement proper user data access controls'
        });

        authzVulnerabilities.add(1);
      }
    }
  }

  async testAPIEndpointAuthorization() {
    console.log('Testing API Endpoint Authorization...');
    
    // Test unauthenticated access to protected endpoints
    const protectedEndpoints = [
      { endpoint: '/users/profile', method: 'GET' },
      { endpoint: '/content/create', method: 'POST' },
      { endpoint: '/payments/create', method: 'POST' },
      { endpoint: '/earnings/withdraw', method: 'POST' },
      { endpoint: '/admin/users', method: 'GET' }
    ];

    for (const test of protectedEndpoints) {
      let response;
      
      if (test.method === 'POST') {
        response = http.post(`${this.baseUrl}${this.apiPrefix}${test.endpoint}`,
          JSON.stringify({}),
          { headers: { 'Content-Type': 'application/json' } }
        );
      } else {
        response = http.get(`${this.baseUrl}${this.apiPrefix}${test.endpoint}`);
      }

      if (response.status === 200 || response.status === 201) {
        this.addFinding({
          category: 'Authorization',
          test: 'API Endpoint Authorization',
          vulnerability: 'Unauthenticated API Access',
          severity: 'critical',
          description: `Protected endpoint accessible without authentication: ${test.endpoint}`,
          evidence: {
            endpoint: test.endpoint,
            method: test.method,
            response: response.status
          },
          impact: 'Unauthorized access to protected API endpoints',
          recommendation: 'Implement authentication checks on all protected endpoints'
        });

        authzVulnerabilities.add(1);
      }
    }
  }

  async testDirectObjectReference() {
    console.log('Testing Insecure Direct Object References...');
    
    if (!this.userTokens.consumer) return;

    // Test direct object reference vulnerabilities
    const dorTests = [
      {
        endpoint: '/content/1',
        description: 'Direct content ID reference'
      },
      {
        endpoint: '/users/1',
        description: 'Direct user ID reference'
      },
      {
        endpoint: '/payments/1',
        description: 'Direct payment ID reference'
      },
      {
        endpoint: '/files/1',
        description: 'Direct file ID reference'
      }
    ];

    for (const test of dorTests) {
      // Try accessing with sequential IDs
      for (let id = 1; id <= 10; id++) {
        const endpoint = test.endpoint.replace(/\d+$/, id.toString());
        const response = http.get(`${this.baseUrl}${this.apiPrefix}${endpoint}`, {
          headers: { 'Authorization': `Bearer ${this.userTokens.consumer}` }
        });

        if (response.status === 200) {
          this.addFinding({
            category: 'Authorization',
            test: 'Insecure Direct Object References',
            vulnerability: 'Direct Object Reference',
            severity: 'medium',
            description: `${test.description}: ${endpoint}`,
            evidence: {
              endpoint: endpoint,
              response: response.status,
              responseBody: response.body.substring(0, 100)
            },
            impact: 'Users can access resources by guessing IDs',
            recommendation: 'Use UUIDs or implement proper authorization checks'
          });

          authzVulnerabilities.add(1);
          break; // Found one, move to next test
        }
      }
    }
  }

  async testParameterTampering() {
    console.log('Testing Parameter Tampering...');
    
    if (!this.userTokens.consumer) return;

    // Test parameter tampering for privilege escalation
    const tamperingTests = [
      {
        endpoint: '/users/profile',
        method: 'PUT',
        tamperParams: { role: 'admin', isAdmin: true, permissions: ['admin'] },
        description: 'Role elevation via parameter tampering'
      },
      {
        endpoint: '/payments/create',
        method: 'POST',
        tamperParams: { amount: 0, discount: 100, price: 0 },
        description: 'Price manipulation via parameter tampering'
      },
      {
        endpoint: '/content/purchase',
        method: 'POST',
        tamperParams: { userId: 'other-user-id', paymentMethod: 'free' },
        description: 'User impersonation via parameter tampering'
      }
    ];

    for (const test of tamperingTests) {
      let response;
      
      if (test.method === 'POST') {
        response = http.post(`${this.baseUrl}${this.apiPrefix}${test.endpoint}`,
          JSON.stringify(test.tamperParams),
          {
            headers: {
              'Authorization': `Bearer ${this.userTokens.consumer}`,
              'Content-Type': 'application/json'
            }
          }
        );
      } else if (test.method === 'PUT') {
        response = http.put(`${this.baseUrl}${this.apiPrefix}${test.endpoint}`,
          JSON.stringify(test.tamperParams),
          {
            headers: {
              'Authorization': `Bearer ${this.userTokens.consumer}`,
              'Content-Type': 'application/json'
            }
          }
        );
      }

      if (response && (response.status === 200 || response.status === 201)) {
        this.addFinding({
          category: 'Authorization',
          test: 'Parameter Tampering',
          vulnerability: 'Parameter Tampering Success',
          severity: 'high',
          description: test.description,
          evidence: {
            endpoint: test.endpoint,
            method: test.method,
            tamperParams: test.tamperParams,
            response: response.status
          },
          impact: 'Users can manipulate parameters to gain unauthorized access or privileges',
          recommendation: 'Implement server-side validation and authorization checks'
        });

        authzVulnerabilities.add(1);
      }
    }
  }

  async testRoleManipulation() {
    if (!this.userTokens.consumer) return;

    // Test role manipulation in various request parts
    const roleManipulationTests = [
      {
        name: 'Header Role Injection',
        headers: { 'X-User-Role': 'admin', 'X-Role': 'admin' }
      },
      {
        name: 'Query Parameter Role',
        queryParams: '?role=admin&userRole=admin'
      },
      {
        name: 'Body Role Injection',
        body: { role: 'admin', userRole: 'admin', isAdmin: true }
      }
    ];

    for (const test of roleManipulationTests) {
      const endpoint = '/users/profile';
      let response;

      if (test.body) {
        response = http.put(`${this.baseUrl}${this.apiPrefix}${endpoint}`,
          JSON.stringify(test.body),
          {
            headers: {
              'Authorization': `Bearer ${this.userTokens.consumer}`,
              'Content-Type': 'application/json',
              ...test.headers
            }
          }
        );
      } else {
        const url = `${this.baseUrl}${this.apiPrefix}${endpoint}${test.queryParams || ''}`;
        response = http.get(url, {
          headers: {
            'Authorization': `Bearer ${this.userTokens.consumer}`,
            ...test.headers
          }
        });
      }

      // Check if role was elevated in response
      if (response.status === 200 && response.body.includes('admin')) {
        this.addFinding({
          category: 'Authorization',
          test: 'Role Manipulation',
          vulnerability: test.name,
          severity: 'critical',
          description: `Role manipulation successful via ${test.name}`,
          evidence: {
            test: test.name,
            response: response.status,
            responseBody: response.body.substring(0, 200)
          },
          impact: 'Users can elevate their privileges through role manipulation',
          recommendation: 'Implement proper role validation and never trust client-side role information'
        });

        authzVulnerabilities.add(1);
        privilegeEscalations.add(1);
      }
    }
  }

  async testJWTPrivilegeEscalation() {
    if (!this.userTokens.consumer) return;

    // Test JWT payload manipulation for privilege escalation
    const token = this.userTokens.consumer;
    const manipulatedTokens = [
      this.manipulateJWTPayload(token, { role: 'admin' }),
      this.manipulateJWTPayload(token, { isAdmin: true }),
      this.manipulateJWTPayload(token, { permissions: ['admin', 'moderator'] }),
      this.manipulateJWTPayload(token, { userId: 'admin-user-id' })
    ];

    for (const manipulatedToken of manipulatedTokens) {
      const response = http.get(`${this.baseUrl}${this.apiPrefix}/admin/users`, {
        headers: { 'Authorization': `Bearer ${manipulatedToken}` }
      });

      if (response.status === 200) {
        this.addFinding({
          category: 'Authorization',
          test: 'JWT Privilege Escalation',
          vulnerability: 'JWT Payload Manipulation',
          severity: 'critical',
          description: 'JWT payload manipulation allowed privilege escalation',
          evidence: {
            originalToken: token.substring(0, 50) + '...',
            manipulatedToken: manipulatedToken.substring(0, 50) + '...',
            response: response.status
          },
          impact: 'Users can escalate privileges by manipulating JWT tokens',
          recommendation: 'Implement proper JWT signature validation and server-side role verification'
        });

        authzVulnerabilities.add(1);
        privilegeEscalations.add(1);
      }
    }
  }

  async testParameterManipulation() {
    if (!this.userTokens.consumer) return;

    // Test parameter manipulation for horizontal access
    const manipulationTests = [
      {
        endpoint: '/users/profile',
        params: { userId: 'other-user-id' },
        method: 'GET'
      },
      {
        endpoint: '/payments/history',
        params: { userAddress: '0x1234567890123456789012345678901234567890' },
        method: 'GET'
      },
      {
        endpoint: '/content/manage',
        params: { contentId: 'other-user-content-id' },
        method: 'GET'
      }
    ];

    for (const test of manipulationTests) {
      const queryString = new URLSearchParams(test.params).toString();
      const response = http.get(`${this.baseUrl}${this.apiPrefix}${test.endpoint}?${queryString}`, {
        headers: { 'Authorization': `Bearer ${this.userTokens.consumer}` }
      });

      if (response.status === 200) {
        this.addFinding({
          category: 'Authorization',
          test: 'Parameter Manipulation',
          vulnerability: 'Horizontal Access via Parameter Manipulation',
          severity: 'high',
          description: `Parameter manipulation allowed access to other user's data: ${test.endpoint}`,
          evidence: {
            endpoint: test.endpoint,
            params: test.params,
            response: response.status
          },
          impact: 'Users can access other users\' data by manipulating parameters',
          recommendation: 'Implement proper parameter validation and ownership checks'
        });

        authzVulnerabilities.add(1);
      }
    }
  }

  // Helper methods
  extractToken(response) {
    try {
      const body = JSON.parse(response.body);
      return body.token || body.accessToken || body.jwt;
    } catch {
      return null;
    }
  }

  manipulateJWTPayload(token, newClaims) {
    try {
      const parts = token.split('.');
      const payload = JSON.parse(atob(parts[1]));
      Object.assign(payload, newClaims);
      const newPayload = btoa(JSON.stringify(payload));
      return `${parts[0]}.${newPayload}.${parts[2]}`;
    } catch {
      return token;
    }
  }

  addFinding(finding) {
    this.findings.push({
      ...finding,
      timestamp: new Date().toISOString(),
      testId: `authz_${this.findings.length + 1}`
    });
  }
}