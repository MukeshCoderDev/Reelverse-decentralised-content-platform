#!/usr/bin/env node

/**
 * Penetration Testing Runner
 * Orchestrates comprehensive penetration testing of backend services
 */

import { execSync } from 'child_process';
import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'fs';
import path from 'path';
import { AuthenticationTests } from './modules/authentication-tests.js';
import { AuthorizationTests } from './modules/authorization-tests.js';
import { InjectionTests } from './modules/injection-tests.js';

class PenetrationTestRunner {
  constructor() {
    this.resultsDir = path.join(process.cwd(), 'tests/pentest/results');
    this.configPath = path.join(process.cwd(), 'tests/pentest/pentest-config.json');
    this.config = this.loadConfig();
    this.findings = [];
    this.ensureDirectories();
  }

  ensureDirectories() {
    if (!existsSync(this.resultsDir)) {
      mkdirSync(this.resultsDir, { recursive: true });
    }
  }

  loadConfig() {
    try {
      const configData = readFileSync(this.configPath, 'utf8');
      return JSON.parse(configData);
    } catch (error) {
      console.error('Failed to load pentest config:', error.message);
      return this.getDefaultConfig();
    }
  }

  getDefaultConfig() {
    return {
      target: {
        baseUrl: 'http://localhost:3001',
        apiPrefix: '/api/v1',
        timeout: 30000
      },
      authentication: {
        testUsers: [
          { role: 'admin', email: 'admin@test.com' },
          { role: 'creator', email: 'creator@test.com' },
          { role: 'consumer', email: 'consumer@test.com' }
        ]
      },
      testCategories: {
        authentication: { enabled: true, severity: 'critical' },
        authorization: { enabled: true, severity: 'critical' },
        injection: { enabled: true, severity: 'critical' }
      }
    };
  }

  async runFullPentest() {
    console.log('üîç Starting Comprehensive Penetration Test');
    console.log('=' .repeat(60));
    console.log(`Target: ${this.config.target.baseUrl}`);
    console.log(`API Prefix: ${this.config.target.apiPrefix}`);
    console.log('=' .repeat(60));

    const pentestResults = {
      timestamp: new Date().toISOString(),
      target: this.config.target,
      testResults: {},
      summary: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        informational: 0,
        total: 0
      },
      passed: false,
      executionTime: 0
    };

    const startTime = Date.now();

    try {
      // 1. Pre-test validation
      await this.validateTarget();

      // 2. Run test modules
      if (this.config.testCategories.authentication?.enabled) {
        console.log('\nüîê Running Authentication Tests...');
        pentestResults.testResults.authentication = await this.runAuthenticationTests();
      }

      if (this.config.testCategories.authorization?.enabled) {
        console.log('\nüîí Running Authorization Tests...');
        pentestResults.testResults.authorization = await this.runAuthorizationTests();
      }

      if (this.config.testCategories.injection?.enabled) {
        console.log('\nüíâ Running Injection Tests...');
        pentestResults.testResults.injection = await this.runInjectionTests();
      }

      // 3. Additional test modules (if implemented)
      await this.runAdditionalTests(pentestResults);

      // 4. Compile results
      this.compileResults(pentestResults);

      // 5. Generate reports
      await this.generateReports(pentestResults);

      // 6. Evaluate security posture
      const securityPosture = this.evaluateSecurityPosture(pentestResults);
      pentestResults.passed = securityPosture.passed;

      pentestResults.executionTime = Date.now() - startTime;

      if (securityPosture.passed) {
        console.log('\nüéâ PENETRATION TEST PASSED - SECURITY POSTURE ACCEPTABLE');
        process.exit(0);
      } else {
        console.log('\nüö® PENETRATION TEST FAILED - CRITICAL VULNERABILITIES FOUND');
        console.log('Critical Issues:', securityPosture.criticalIssues);
        process.exit(1);
      }

    } catch (error) {
      console.error('‚ùå Penetration test failed:', error);
      process.exit(1);
    }
  }

  async validateTarget() {
    console.log('üéØ Validating target availability...');
    
    try {
      // Use k6 for HTTP requests since we're in a k6 context
      const response = await fetch(`${this.config.target.baseUrl}/health`);
      
      if (!response.ok) {
        console.warn('‚ö†Ô∏è  Target health check failed, continuing with tests...');
      } else {
        console.log('‚úÖ Target is accessible');
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è  Could not validate target, continuing with tests...');
    }
  }

  async runAuthenticationTests() {
    const authTests = new AuthenticationTests(this.config);
    const findings = await authTests.runAllTests();
    
    console.log(`‚úÖ Authentication tests completed: ${findings.length} findings`);
    return {
      findings: findings,
      summary: this.summarizeFindings(findings),
      executionTime: Date.now()
    };
  }

  async runAuthorizationTests() {
    const authzTests = new AuthorizationTests(this.config);
    const findings = await authzTests.runAllTests();
    
    console.log(`‚úÖ Authorization tests completed: ${findings.length} findings`);
    return {
      findings: findings,
      summary: this.summarizeFindings(findings),
      executionTime: Date.now()
    };
  }

  async runInjectionTests() {
    const injectionTests = new InjectionTests(this.config);
    const findings = await injectionTests.runAllTests();
    
    console.log(`‚úÖ Injection tests completed: ${findings.length} findings`);
    return {
      findings: findings,
      summary: this.summarizeFindings(findings),
      executionTime: Date.now()
    };
  }

  async runAdditionalTests(pentestResults) {
    // Placeholder for additional test modules
    // These would be implemented as separate modules like:
    // - Input Validation Tests
    // - Session Management Tests
    // - Business Logic Tests
    // - Information Disclosure Tests
    // - Cryptography Tests
    
    console.log('üìã Additional test modules not implemented yet');
  }

  compileResults(pentestResults) {
    // Compile all findings from different test modules
    this.findings = [];
    
    Object.values(pentestResults.testResults).forEach(testResult => {
      if (testResult.findings) {
        this.findings.push(...testResult.findings);
      }
    });

    // Calculate overall summary
    pentestResults.summary = this.summarizeFindings(this.findings);
    pentestResults.summary.total = this.findings.length;

    console.log('\nüìä Test Results Summary:');
    console.log(`Critical: ${pentestResults.summary.critical}`);
    console.log(`High: ${pentestResults.summary.high}`);
    console.log(`Medium: ${pentestResults.summary.medium}`);
    console.log(`Low: ${pentestResults.summary.low}`);
    console.log(`Total Findings: ${pentestResults.summary.total}`);
  }

  summarizeFindings(findings) {
    const summary = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      informational: 0
    };

    findings.forEach(finding => {
      switch (finding.severity.toLowerCase()) {
        case 'critical':
          summary.critical++;
          break;
        case 'high':
          summary.high++;
          break;
        case 'medium':
          summary.medium++;
          break;
        case 'low':
          summary.low++;
          break;
        default:
          summary.informational++;
      }
    });

    return summary;
  }

  async generateReports(pentestResults) {
    console.log('\nüìã Generating penetration test reports...');

    // Generate JSON report
    const jsonReportPath = path.join(this.resultsDir, 'pentest-report.json');
    writeFileSync(jsonReportPath, JSON.stringify(pentestResults, null, 2));

    // Generate HTML report
    const htmlReportPath = path.join(this.resultsDir, 'pentest-report.html');
    const htmlReport = this.generateHTMLReport(pentestResults);
    writeFileSync(htmlReportPath, htmlReport);

    // Generate executive summary
    const summaryPath = path.join(this.resultsDir, 'executive-summary.md');
    const summary = this.generateExecutiveSummary(pentestResults);
    writeFileSync(summaryPath, summary);

    // Generate findings CSV
    const csvPath = path.join(this.resultsDir, 'findings.csv');
    const csvReport = this.generateCSVReport(this.findings);
    writeFileSync(csvPath, csvReport);

    console.log(`üìÑ JSON Report: ${jsonReportPath}`);
    console.log(`üåê HTML Report: ${htmlReportPath}`);
    console.log(`üìù Executive Summary: ${summaryPath}`);
    console.log(`üìä CSV Export: ${csvPath}`);
  }

  generateHTMLReport(pentestResults) {
    const findings = this.findings;
    const summary = pentestResults.summary;

    return `<!DOCTYPE html>
<html>
<head>
    <title>Penetration Test Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #f4f4f4; padding: 20px; border-radius: 5px; }
        .summary { display: flex; gap: 20px; margin: 20px 0; }
        .metric { background: #e9ecef; padding: 15px; border-radius: 5px; text-align: center; }
        .critical { background: #dc3545; color: white; }
        .high { background: #fd7e14; color: white; }
        .medium { background: #ffc107; color: black; }
        .low { background: #28a745; color: white; }
        .finding { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
        .severity-critical { border-left: 5px solid #dc3545; }
        .severity-high { border-left: 5px solid #fd7e14; }
        .severity-medium { border-left: 5px solid #ffc107; }
        .severity-low { border-left: 5px solid #28a745; }
        .evidence { background: #f8f9fa; padding: 10px; border-radius: 3px; font-family: monospace; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Penetration Test Report</h1>
        <p><strong>Target:</strong> ${pentestResults.target.baseUrl}</p>
        <p><strong>Date:</strong> ${pentestResults.timestamp}</p>
        <p><strong>Duration:</strong> ${Math.round(pentestResults.executionTime / 1000)}s</p>
    </div>

    <div class="summary">
        <div class="metric critical">
            <h3>${summary.critical}</h3>
            <p>Critical</p>
        </div>
        <div class="metric high">
            <h3>${summary.high}</h3>
            <p>High</p>
        </div>
        <div class="metric medium">
            <h3>${summary.medium}</h3>
            <p>Medium</p>
        </div>
        <div class="metric low">
            <h3>${summary.low}</h3>
            <p>Low</p>
        </div>
    </div>

    <h2>Findings</h2>
    ${findings.map(finding => `
        <div class="finding severity-${finding.severity.toLowerCase()}">
            <h3>${finding.vulnerability}</h3>
            <p><strong>Category:</strong> ${finding.category}</p>
            <p><strong>Severity:</strong> ${finding.severity}</p>
            <p><strong>Description:</strong> ${finding.description}</p>
            <p><strong>Impact:</strong> ${finding.impact}</p>
            <p><strong>Recommendation:</strong> ${finding.recommendation}</p>
            <div class="evidence">
                <strong>Evidence:</strong><br>
                <pre>${JSON.stringify(finding.evidence, null, 2)}</pre>
            </div>
        </div>
    `).join('')}
</body>
</html>`;
  }

  generateExecutiveSummary(pentestResults) {
    const summary = pentestResults.summary;
    const riskLevel = this.calculateRiskLevel(summary);

    return `# Penetration Test Executive Summary

**Date:** ${pentestResults.timestamp}
**Target:** ${pentestResults.target.baseUrl}
**Duration:** ${Math.round(pentestResults.executionTime / 1000)} seconds
**Overall Risk Level:** ${riskLevel}

## Summary

This penetration test assessed the security posture of the backend services for the adult content platform. The assessment covered authentication, authorization, and injection vulnerabilities.

## Key Findings

- **Critical Vulnerabilities:** ${summary.critical}
- **High Risk Issues:** ${summary.high}
- **Medium Risk Issues:** ${summary.medium}
- **Low Risk Issues:** ${summary.low}
- **Total Findings:** ${summary.total}

## Risk Assessment

${this.getRiskAssessmentText(summary)}

## Recommendations

### Immediate Actions (Critical/High)
${this.getImmediateRecommendations()}

### Short-term Actions (Medium)
${this.getShortTermRecommendations()}

### Long-term Actions (Low)
${this.getLongTermRecommendations()}

## Conclusion

${this.getConclusion(pentestResults)}

---
*This report was generated automatically by the Go-Live Sprint Penetration Testing Suite*
`;
  }

  generateCSVReport(findings) {
    const headers = ['ID', 'Category', 'Test', 'Vulnerability', 'Severity', 'Description', 'Impact', 'Recommendation', 'Timestamp'];
    const rows = findings.map(finding => [
      finding.testId,
      finding.category,
      finding.test,
      finding.vulnerability,
      finding.severity,
      `"${finding.description}"`,
      `"${finding.impact}"`,
      `"${finding.recommendation}"`,
      finding.timestamp
    ]);

    return [headers.join(','), ...rows.map(row => row.join(','))].join('\n');
  }

  evaluateSecurityPosture(pentestResults) {
    const summary = pentestResults.summary;
    const criticalIssues = [];

    // Define go/no-go criteria
    const criteria = {
      noCritical: summary.critical === 0,
      maxHigh: summary.high <= 3,
      maxMedium: summary.medium <= 10
    };

    if (!criteria.noCritical) {
      criticalIssues.push(`${summary.critical} critical vulnerabilities found`);
    }
    if (!criteria.maxHigh) {
      criticalIssues.push(`${summary.high} high-severity vulnerabilities exceed limit of 3`);
    }
    if (!criteria.maxMedium) {
      criticalIssues.push(`${summary.medium} medium-severity vulnerabilities exceed limit of 10`);
    }

    const passed = Object.values(criteria).every(criterion => criterion);

    return {
      passed,
      criticalIssues,
      criteria
    };
  }

  calculateRiskLevel(summary) {
    if (summary.critical > 0) return 'CRITICAL';
    if (summary.high > 3) return 'HIGH';
    if (summary.high > 0 || summary.medium > 5) return 'MEDIUM';
    return 'LOW';
  }

  getRiskAssessmentText(summary) {
    if (summary.critical > 0) {
      return 'The application has critical security vulnerabilities that pose immediate risk to the platform and user data. Immediate remediation is required before go-live.';
    }
    if (summary.high > 3) {
      return 'The application has multiple high-severity vulnerabilities that could be exploited by attackers. These should be addressed before production deployment.';
    }
    if (summary.high > 0 || summary.medium > 5) {
      return 'The application has some security issues that should be addressed to improve the overall security posture.';
    }
    return 'The application demonstrates a good security posture with minimal security issues identified.';
  }

  getImmediateRecommendations() {
    const criticalFindings = this.findings.filter(f => f.severity.toLowerCase() === 'critical');
    const highFindings = this.findings.filter(f => f.severity.toLowerCase() === 'high');
    
    const recommendations = new Set();
    [...criticalFindings, ...highFindings].forEach(finding => {
      recommendations.add(`- ${finding.recommendation}`);
    });
    
    return Array.from(recommendations).join('\n') || '- No immediate actions required';
  }

  getShortTermRecommendations() {
    const mediumFindings = this.findings.filter(f => f.severity.toLowerCase() === 'medium');
    
    const recommendations = new Set();
    mediumFindings.forEach(finding => {
      recommendations.add(`- ${finding.recommendation}`);
    });
    
    return Array.from(recommendations).join('\n') || '- No short-term actions required';
  }

  getLongTermRecommendations() {
    return `- Implement regular security assessments
- Establish secure coding practices
- Conduct security training for development team
- Implement automated security testing in CI/CD pipeline
- Regular dependency updates and vulnerability scanning`;
  }

  getConclusion(pentestResults) {
    if (pentestResults.passed) {
      return 'The penetration test results indicate that the application has an acceptable security posture for production deployment. Continue monitoring and regular security assessments.';
    } else {
      return 'The penetration test identified critical security issues that must be addressed before production deployment. Remediate all critical and high-severity findings and re-test before go-live.';
    }
  }

  async runQuickScan() {
    console.log('‚ö° Running Quick Security Scan');
    
    // Run only critical tests
    const authTests = new AuthenticationTests(this.config);
    const authFindings = await authTests.runAllTests();
    
    const summary = this.summarizeFindings(authFindings);
    
    console.log('Quick Scan Results:');
    console.log(`Critical: ${summary.critical}`);
    console.log(`High: ${summary.high}`);
    console.log(`Total: ${authFindings.length}`);
    
    return summary.critical === 0 && summary.high <= 1;
  }
}

// CLI Interface
async function main() {
  const runner = new PenetrationTestRunner();
  const args = process.argv.slice(2);

  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
Go-Live Sprint Penetration Testing Runner

Usage:
  node tests/pentest/run-pentest.js           # Run full penetration test
  node tests/pentest/run-pentest.js --quick   # Run quick security scan

Options:
  --quick       Run quick security scan (authentication only)
  --help, -h    Show this help message

Examples:
  node tests/pentest/run-pentest.js
  node tests/pentest/run-pentest.js --quick
`);
    process.exit(0);
  }

  if (args.includes('--quick')) {
    const passed = await runner.runQuickScan();
    process.exit(passed ? 0 : 1);
  } else {
    await runner.runFullPentest();
  }
}

if (require.main === module) {
  main().catch(error => {
    console.error('‚ùå Penetration test runner failed:', error);
    process.exit(1);
  });
}

export { PenetrationTestRunner };