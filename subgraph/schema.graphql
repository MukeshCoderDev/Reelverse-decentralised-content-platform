type Creator @entity {
  id: ID! # wallet address
  walletAddress: Bytes!
  isVerified: Boolean!
  verificationSBT: Bytes # SBT token ID if verified
  totalEarnings: BigInt!
  totalContent: BigInt!
  createdAt: BigInt!
  updatedAt: BigInt!
  
  # Relationships
  content: [Content!]! @derivedFrom(field: "creator")
  revenueSplits: [RevenueSplit!]! @derivedFrom(field: "creator")
  moderationActions: [ModerationAction!]! @derivedFrom(field: "creator")
  organization: Organization
}

type Organization @entity {
  id: ID! # organization contract address
  name: String!
  owner: Creator!
  totalMembers: BigInt!
  totalContent: BigInt!
  totalEarnings: BigInt!
  createdAt: BigInt!
  
  # Relationships
  members: [Creator!]!
  content: [Content!]! @derivedFrom(field: "organization")
}

type Content @entity {
  id: ID! # content ID from contract
  contentId: BigInt!
  creator: Creator!
  organization: Organization
  title: String!
  description: String
  metadataURI: String!
  perceptualHash: Bytes!
  isActive: Boolean!
  moderationStatus: ModerationStatus!
  geoRestrictions: BigInt! # bitmask
  createdAt: BigInt!
  updatedAt: BigInt!
  
  # Relationships
  entitlements: [Entitlement!]! @derivedFrom(field: "content")
  purchases: [Purchase!]! @derivedFrom(field: "content")
  revenueSplits: [RevenueSplit!]! @derivedFrom(field: "content")
  moderationActions: [ModerationAction!]! @derivedFrom(field: "content")
}

enum ModerationStatus {
  PENDING
  APPROVED
  REJECTED
  FLAGGED
  REMOVED
}

type Entitlement @entity {
  id: ID! # tokenId from NFTAccess contract
  tokenId: BigInt!
  content: Content!
  entitlementType: EntitlementType!
  price: BigInt!
  currency: String! # "USDC" or "USD"
  maxSupply: BigInt!
  currentSupply: BigInt!
  expiryDuration: BigInt! # seconds, 0 for permanent
  isActive: Boolean!
  createdAt: BigInt!
  
  # Relationships
  purchases: [Purchase!]! @derivedFrom(field: "entitlement")
}

enum EntitlementType {
  PPV # Pay-per-view
  SUBSCRIPTION # Time-based subscription
  BUNDLE # Bundle of content
  TIER # Creator tier access
}

type Purchase @entity {
  id: ID! # transaction hash + log index
  buyer: Bytes!
  content: Content!
  entitlement: Entitlement!
  amount: BigInt!
  currency: String!
  paymentMethod: PaymentMethod!
  transactionHash: Bytes!
  blockNumber: BigInt!
  timestamp: BigInt!
  
  # Revenue split tracking
  revenueSplit: RevenueSplit
}

enum PaymentMethod {
  CRYPTO_USDC
  FIAT_CARD
  FIAT_BANK
}

type RevenueSplit @entity {
  id: ID! # content ID + creator address
  content: Content!
  creator: Creator!
  percentage: BigInt! # basis points (10000 = 100%)
  totalEarnings: BigInt!
  totalWithdrawn: BigInt!
  createdAt: BigInt!
  updatedAt: BigInt!
  
  # Relationships
  purchases: [Purchase!]! @derivedFrom(field: "revenueSplit")
  payouts: [Payout!]! @derivedFrom(field: "revenueSplit")
}

type Payout @entity {
  id: ID! # transaction hash
  revenueSplit: RevenueSplit!
  recipient: Bytes!
  amount: BigInt!
  currency: String!
  payoutMethod: PayoutMethod!
  transactionHash: Bytes
  status: PayoutStatus!
  requestedAt: BigInt!
  processedAt: BigInt
}

enum PayoutMethod {
  CRYPTO_INSTANT # Direct USDC transfer
  FIAT_PAXUM # Paxum integration
  FIAT_BANK # Bank transfer
}

enum PayoutStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

type ModerationAction @entity {
  id: ID! # transaction hash + log index
  content: Content!
  creator: Creator!
  moderator: Bytes!
  action: ModerationActionType!
  reason: String
  evidence: String # IPFS hash of evidence
  timestamp: BigInt!
  transactionHash: Bytes!
}

enum ModerationActionType {
  APPROVE
  REJECT
  FLAG
  REMOVE
  RESTORE
  DMCA_TAKEDOWN
}

# Analytics aggregation entities
type DailyStats @entity {
  id: ID! # date in YYYY-MM-DD format
  date: String!
  totalCreators: BigInt!
  totalContent: BigInt!
  totalPurchases: BigInt!
  totalRevenue: BigInt!
  newCreators: BigInt!
  newContent: BigInt!
  activeCreators: BigInt! # creators with activity that day
}

type CreatorStats @entity {
  id: ID! # creator address + date
  creator: Creator!
  date: String!
  totalEarnings: BigInt!
  totalViews: BigInt!
  totalPurchases: BigInt!
  newContent: BigInt!
}

# Platform metrics for public status page
type PlatformMetrics @entity {
  id: ID! # always "current"
  totalCreators: BigInt!
  totalContent: BigInt!
  totalRevenue: BigInt!
  totalPayouts: BigInt!
  averageJoinTime: BigInt! # milliseconds
  rebufferRate: BigInt! # basis points
  uptimePercentage: BigInt! # basis points
  lastUpdated: BigInt!
}

# Compliance and audit trail
type ConsentRecord @entity {
  id: ID! # scene hash
  sceneHash: Bytes!
  content: Content!
  participants: [Bytes!]!
  consentHashes: [Bytes!]! # EIP-712 signature hashes
  isComplete: Boolean!
  createdAt: BigInt!
  updatedAt: BigInt!
}

type AuditLog @entity {
  id: ID! # transaction hash + log index
  entity: String! # "Creator", "Content", etc.
  entityId: String!
  action: String!
  actor: Bytes!
  metadata: String # JSON string
  timestamp: BigInt!
  transactionHash: Bytes!
}

# Age verification tracking
type AgeVerification @entity {
  id: ID! # wallet address
  user: Bytes!
  isVerified: Boolean!
  verificationMethod: String! # "KYC", "SBT", etc.
  verifiedAt: BigInt!
  expiresAt: BigInt
  sbtTokenId: Bytes
}

# DMCA and anti-piracy
type DMCANotice @entity {
  id: ID! # notice ID
  content: Content!
  claimant: Bytes!
  targetUrl: String!
  status: DMCAStatus!
  filedAt: BigInt!
  resolvedAt: BigInt
  evidence: String # IPFS hash
}

enum DMCAStatus {
  FILED
  PROCESSING
  TAKEDOWN_SENT
  REMOVED
  DISPUTED
  RESOLVED
}